<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architectural AI Reverse Engineering Dashboard</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-background: #09090b;
            --bg-card: #18181b;
            --bg-muted: #27272a;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent-primary: #3b82f6;
            --accent-success: #10b981;
            --border-color: #27272a;
            --grid-color: rgba(255, 255, 255, 0.05);
        }

        @font-face {
            font-family: 'Inter';
            src: url('https://assets-persist.lovart.ai/agent-static-assets/NotoSansHans-Regular.otf');
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-background);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            width: 100vw; height: 100vh;
            overflow: hidden; display: flex; flex-direction: column;
        }

        header {
            height: 64px; border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 24px; background-color: var(--bg-background);
        }

        .header-left { display: flex; align-items: center; gap: 12px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: linear-gradient(135deg, var(--accent-primary), #60a5fa);
            border-radius: 6px; display: flex; align-items: center; justify-content: center;
            color: white; font-size: 18px;
        }
        .header-title { font-weight: bold; font-size: 18px; }

        .header-right { display: flex; gap: 12px; align-items: center; }

        .btn {
            height: 36px; padding: 0 16px; border-radius: 6px;
            font-size: 14px; display: flex; align-items: center; gap: 8px;
            cursor: pointer; transition: all 0.2s; border: 1px solid transparent;
        }
        .btn-outline { background: transparent; border-color: var(--border-color); color: var(--text-primary); }
        .btn-primary { background: var(--text-primary); color: var(--bg-background); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }

        :root { --terminal-height: 190px; }
        .main-container { display: flex; flex: 1; height: calc(100vh - 64px); min-height: 0; position: relative; padding-bottom: var(--terminal-height); }

        .sidebar {
            width: 320px; border-right: 1px solid var(--border-color);
            padding: 32px 24px; background-color: var(--bg-background);
            display: flex; flex-direction: column; gap: 8px;
        }

        .step-item {
            position: relative; padding: 16px; border-radius: 8px;
            cursor: pointer; border: 1px solid transparent;
            transition: all 0.2s; display: flex; gap: 16px;
            width: 100%; text-align: left; background: none; color: inherit;
        }
        .step-item.active { background-color: var(--bg-card); border-color: var(--border-color); }
        .step-indicator {
            width: 24px; height: 24px; border-radius: 50%;
            background-color: var(--bg-muted); border: 2px solid var(--border-color);
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; font-weight: bold; color: var(--text-muted);
        }
        .step-item.active .step-indicator { background-color: var(--accent-primary); color: white; }
        .step-item.completed {
            background: rgba(16,185,129,0.14);
            border-color: rgba(16,185,129,0.35);
        }
        .step-item.completed .step-indicator { background-color: var(--accent-success); color: white; border-color: rgba(16,185,129,0.45); }
        .step-item.completed .step-title { color: rgba(167,243,208,0.95); }
        .step-item.completed .step-desc { color: rgba(167,243,208,0.70); }
        .step-title { font-size: 14px; font-weight: 500; margin-bottom: 4px; }
        .step-desc { font-size: 12px; color: var(--text-muted); }

        .canvas-area {
            flex: 1; background-color: #000;
            background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px; position: relative;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }

        .viewport-card { width: 100%; height: 100%; position: relative; display: flex; flex-direction: column; }
        .viewport-content { flex: 1; position: relative; background: #111; }
        .vis-layer { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; }

        .data-panel {
            width: 350px; border-left: 1px solid var(--border-color);
            background-color: var(--bg-background); padding: 24px;
            display: flex; flex-direction: column; gap: 24px; overflow-y: auto;
        }
        .panel-section-title { font-size: 14px; font-weight: bold; margin-bottom: 12px; display: flex; justify-content: space-between; }
        .data-card { background-color: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; }
        .metric-row { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .metric-label { font-size: 12px; color: var(--text-muted); }
        .metric-value { font-size: 16px; font-weight: bold; }

        .log-container {
            font-family: monospace; font-size: 11px; color: var(--text-secondary);
            background: #111; padding: 12px; border-radius: 6px; height: 120px;
            overflow-y: auto; border: 1px solid var(--border-color);
        }
        .log-entry { margin-bottom: 4px; }
        .log-msg.info { color: #60a5fa; }
        .log-msg.success { color: #34d399; }

        #caseSelectorModal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center; }
        .case-card { background: var(--bg-muted); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; cursor: pointer; transition: transform 0.2s; }
        .case-card:hover { transform: scale(1.05); }

        .prop-item { background: var(--bg-muted); padding: 10px; border-radius: 6px; }
        .prop-label { font-size: 10px; color: var(--text-muted); margin-bottom: 2px; }
        .prop-val { font-size: 13px; font-weight: 500; }
        .property-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        /* Building selector layout */
        .building-modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 32px;
            width: min(1100px, calc(100vw - 48px));
        }
        #caseList { display: grid; grid-template-columns: 1fr; gap: 16px; margin-bottom: 24px; }
        .case-card { cursor: default; }

        /* Sidebar connector lines (Step 1->2->3->4) */
        .sidebar { position: relative; }
        .step-connector {
            position: absolute;
            width: 2px;
            background: rgba(255,255,255,0.18);
            border-radius: 2px;
            pointer-events: none;
        }
        .step-connector.active { background: rgba(16,185,129,0.35); }
        .step-dot {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 999px;
            background: rgba(16,185,129,1);
            box-shadow: 0 0 18px rgba(16,185,129,0.85), 0 0 4px rgba(16,185,129,1);
            opacity: 0;
            transform: translateY(0);
            pointer-events: none;
        }

        /* VS Code-like terminal panel */
        #terminal-panel {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: var(--terminal-height);
            background: rgba(0,0,0,0.72);
            border-top: 1px solid rgba(255,255,255,0.12);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            z-index: 50;
        }
        #terminal-header {
            height: 34px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: rgba(255,255,255,0.75);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            user-select: none;
        }
        #terminal-title {
            display: flex;
            gap: 10px;
            align-items: center;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        #terminal-output {
            flex: 1;
            overflow-y: auto;
            padding: 10px 12px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.4;
            color: rgba(34,197,94,0.95);
            white-space: pre-wrap;
        }
        .terminal-dim { color: rgba(34,197,94,0.65); }
        .terminal-warn { color: rgba(251,191,36,0.95); }
        .terminal-error { color: rgba(248,113,113,0.95); }
    </style>
</head>
<body>
    <header>
        <div class="header-left">
            <div class="logo-icon"><i class="ri-building-2-line"></i></div>
            <div class="header-title">StructAI Reverse Engine</div>
        </div>
        <div class="header-right">
            <div id="metricsBar" style="display:flex; gap:10px; align-items:center; margin-right: 12px; font-size: 12px;">
                <span id="metricGpu" style="color: var(--accent-success);">GPU 28%</span>
                <span id="metricVram" style="color: var(--text-secondary);">VRAM 6.2GB</span>
                <span id="metricTemp" style="color: var(--text-secondary);">TEMP 62°C</span>
            </div>
            <button class="btn btn-primary" onclick="showCaseSelector()">
                <i class="ri-folder-open-line"></i> Select Building
            </button>
            <button class="btn btn-outline" onclick="location.reload()">
                <i class="ri-refresh-line"></i> Reset
            </button>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <button class="step-item" id="step1Btn" onclick="runStep1()" disabled>
                <div class="step-indicator">1</div>
                <div class="step-content">
                    <div class="step-title">外观识别</div>
                    <div class="step-desc">结构形式与建成年代识别</div>
                </div>
            </button>
            <button class="step-item" id="step2Btn" onclick="runStep2()" disabled>
                <div class="step-indicator">2</div>
                <div class="step-content">
                    <div class="step-title">语义识别</div>
                    <div class="step-desc">构件分割与坐标映射</div>
                </div>
            </button>
            <button class="step-item" id="step3Btn" onclick="runStep3()" disabled>
                <div class="step-indicator">3</div>
                <div class="step-content">
                    <div class="step-title">几何分析</div>
                    <div class="step-desc">建筑开间与平面布局推测</div>
                </div>
            </button>
            <button class="step-item" id="step4Btn" onclick="runStep4()" disabled>
                <div class="step-indicator">4</div>
                <div class="step-content">
                    <div class="step-title">室内布局生成</div>
                    <div class="step-desc">2D矢量平面图自动重建</div>
                </div>
            </button>
        </div>

        <div class="canvas-area">
            <div class="viewport-card">
                <div class="viewport-content" id="viewportMain">
                    <div class="vis-layer">
                         <img id="mainImage" src="" style="width: 100%; height: 100%; object-fit: fill; display: none;">
                    </div>
                    <div id="detectionLayer" class="vis-layer" style="pointer-events: none;"></div>
                </div>
            </div>
        </div>

        <div class="data-panel">
            <div id="panel1" style="display: none;">
                <div class="panel-section-title">建筑基本信息 <i class="ri-building-line"></i></div>
                <div class="data-card">
                    <div class="metric-row"><span class="metric-label">结构形式</span><span class="metric-value" id="valStructure">-</span></div>
                    <div class="metric-row"><span class="metric-label">建成年代</span><span class="metric-value" id="valYear">-</span></div>
                    <div class="metric-row"><span class="metric-label">建筑用途</span><span class="metric-value" id="valUse">-</span></div>
                </div>
            </div>

            <div id="panel2" style="display: none;">
                <div class="panel-section-title">语义分割统计 <i class="ri-scan-2-line"></i></div>
                <div class="property-grid">
                    <div class="prop-item"><div class="prop-label">窗户数量</div><div class="prop-val" id="countWindow">0</div></div>
                    <div class="prop-item"><div class="prop-label">空调外机</div><div class="prop-val" id="countAC">0</div></div>
                    <div class="prop-item"><div class="prop-label">门/阳台</div><div class="prop-val" id="countOther">0</div></div>
                    <div class="prop-item"><div class="prop-label">识别置信度</div><div class="prop-val">98.2%</div></div>
                </div>
            </div>

            <div id="panel3" style="display: none;">
                <div class="panel-section-title">空间几何分析 <i class="ri-ruler-2-line"></i></div>
                <div class="data-card">
                    <div class="metric-row"><span class="metric-label">识别开间数</span><span class="metric-value" id="valBays">-</span></div>
                    <div class="metric-row"><span class="metric-label">户型对称性</span><span class="metric-value" id="valSymmetry">-</span></div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-secondary);">
                        <div style="margin-bottom: 4px;">● 推测厨房: <span id="valKitchen">-</span></div>
                        <div>● 推测卧室: <span id="valBedroom">-</span></div>
                    </div>
                </div>
            </div>

            <div style="margin-top: auto;">
                <div class="panel-section-title">System Output <i class="ri-terminal-box-line"></i></div>
                <div class="log-container" id="logContainer"></div>
            </div>
        </div>
    </div>

    <div id="terminal-panel">
        <div id="terminal-header">
            <div id="terminal-title">
                <span style="color: rgba(34,197,94,0.95);">TERMINAL</span>
                <span class="terminal-dim">structai-demo</span>
            </div>
            <div class="terminal-dim">UTF-8 • LF</div>
        </div>
        <div id="terminal-output"></div>
    </div>

    <div id="caseSelectorModal">
        <div class="building-modal">
            <h2 style="margin-bottom: 24px;">Select Building</h2>
            <div id="caseList"></div>
            <div style="display: flex; justify-content: flex-end;">
                <button class="btn btn-outline" onclick="document.getElementById('caseSelectorModal').style.display='none'">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const mainImage = document.getElementById('mainImage');
        const detectionLayer = document.getElementById('detectionLayer');
        const API_URL = location.origin;
        let selectedCase = null;
        let step2Data = null;

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        async function streamTechLogs(stepName, lines) {
            // Clear terminal output for each step run to keep it readable.
            const term = document.getElementById('terminal-output');
            if (term) term.innerHTML = '';

            const baseLines = lines && lines.length ? lines : [
                `[${stepName}] initializing pipeline...`,
                `[${stepName}] loading model weights (fp16)`,
                `[${stepName}] warming up kernels`,
                `[${stepName}] allocating GPU tensors`,
                `[${stepName}] running inference batch=1`,
                `[${stepName}] post-processing detections`,
            ];

            const n = Math.floor(5 + Math.random() * 6); // 5-10
            for (let i = 0; i < n; i++) {
                const msg = baseLines[i % baseLines.length];
                log(msg, 'info');
                await sleep(90 + Math.random() * 70); // fast scroll
            }
            log('DONE', 'success');
            await sleep(120);
        }

        function fadeInMainImage(src, objectFit = 'contain') {
            mainImage.style.display = 'block';
            mainImage.style.transition = 'opacity 240ms ease';
            mainImage.style.opacity = '0';
            mainImage.src = src;
            mainImage.style.objectFit = objectFit;
            // allow layout to apply opacity=0 before fading in
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    mainImage.style.opacity = '1';
                });
            });
        }

        function initMetricsTicker() {
        function waitForImageLoad(imgEl, timeoutMs = 15000) {
            return new Promise((resolve) => {
                if (!imgEl) return resolve(false);

                // Important: if the image failed quickly, `complete` may already be true
                // and the `error` event may have fired before we attach listeners.
                // In that case we MUST resolve immediately (and callers can check naturalWidth).
                if (imgEl.complete) return resolve(imgEl.naturalWidth > 0);

                let settled = false;
                const finish = () => {
                    if (settled) return;
                    settled = true;
                    imgEl.removeEventListener('load', finish);
                    imgEl.removeEventListener('error', finish);
                    resolve(imgEl.naturalWidth > 0);
                };

                imgEl.addEventListener('load', finish);
                imgEl.addEventListener('error', finish);

                setTimeout(() => {
                    if (!settled) {
                        settled = true;
                        imgEl.removeEventListener('load', finish);
                        imgEl.removeEventListener('error', finish);
                        resolve(imgEl.naturalWidth > 0);
                    }
                }, timeoutMs);
            });
        }

        function setViewportStatus(text) {
            const viewport = document.getElementById('viewportMain');
            if (!viewport) return;
            let el = document.getElementById('viewportStatus');
            if (!el) {
                el = document.createElement('div');
                el.id = 'viewportStatus';
                el.style.cssText = 'position:absolute; left:14px; top:14px; padding:8px 10px; border-radius:8px; background:rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.12); color:rgba(255,255,255,0.85); font-size:12px; z-index:60; backdrop-filter: blur(8px);';
                viewport.appendChild(el);
            }
            if (!text) {
                el.remove();
                return;
            }
            el.textContent = text;
        }

        async function transitionToOrtho(primarySrc, fallbackSrc) {
            // Crossfade from current image to ortho, keeping consistent geometry (object-fit: fill).
            const viewport = document.getElementById('viewportMain');
            if (!viewport) {
                fadeInMainImage(primarySrc, 'fill');
                return true;
            }

            // Ensure base image uses "fill" so overlay coordinates match.
            mainImage.style.objectFit = 'fill';
            mainImage.style.opacity = '1';

            setViewportStatus('Loading ORTHO view…');

            const overlay = document.createElement('img');
            overlay.referrerPolicy = 'no-referrer';
            overlay.style.cssText = 'position:absolute; inset:0; width:100%; height:100%; object-fit:fill; opacity:0; transition:opacity 380ms ease; pointer-events:none; z-index: 20;';
            viewport.appendChild(overlay);

            const tryLoad = async (src) => {
                overlay.src = src;
                return await waitForImageLoad(overlay, 15000);
            };

            let ok = await tryLoad(primarySrc);
            if (!ok && fallbackSrc) {
                log(`Failed to load ortho preview, falling back to ${fallbackSrc}`, 'warn');
                ok = await tryLoad(fallbackSrc);
            }

            if (!ok) {
                overlay.remove();
                setViewportStatus('');
                log('Ortho image failed to load.', 'warn');
                return false;
            }

            // Fade overlay in and base out.
            mainImage.style.transition = 'opacity 380ms ease';
            mainImage.style.opacity = '0';
            overlay.style.opacity = '1';
            await sleep(420);

            // Commit ortho into mainImage and remove overlay.
            mainImage.src = overlay.src;
            mainImage.referrerPolicy = 'no-referrer';
            mainImage.style.opacity = '1';
            overlay.remove();
            await waitForImageLoad(mainImage, 15000);
            setViewportStatus('');
            return true;
        }

        function ensureOverlaySvg(dims) {
            detectionLayer.innerHTML = '';
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${dims[0]} ${dims[1]}`);
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.style.cssText = 'position:absolute; inset:0; pointer-events:none;';
            detectionLayer.appendChild(svg);
            return svg;
        }

        function pathFromPoints(points) {
            if (!points || points.length === 0) return '';
            const [x0, y0] = points[0];
            let d = `M ${x0} ${y0}`;
            for (let i = 1; i < points.length; i++) {
                const [x, y] = points[i];
                d += ` L ${x} ${y}`;
            }
            return d + ' Z';
        }

        function renderMaskOverlay(masks, dims) {
            const svg = ensureOverlaySvg(dims);
            for (const m of masks || []) {
                const label = m.label || 'unknown';
                const pts = m.points || [];
                if (!pts.length) continue;

                const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                p.setAttribute('d', pathFromPoints(pts));
                const isWindow = String(label).includes('window');
                const stroke = isWindow ? '#f472b6' : '#fbbf24';
                const fill = isWindow ? 'rgba(244,114,182,0.18)' : 'rgba(251,191,36,0.14)';
                p.setAttribute('fill', fill);
                p.setAttribute('stroke', stroke);
                p.setAttribute('stroke-width', '2');
                p.setAttribute('vector-effect', 'non-scaling-stroke');
                svg.appendChild(p);
            }
        }

        function masksToBBoxes(masks) {
            const out = [];
            for (const m of masks || []) {
                const pts = m.points || [];
                if (!pts.length) continue;
                let xMin = Infinity, yMin = Infinity, xMax = -Infinity, yMax = -Infinity;
                for (const [x, y] of pts) {
                    xMin = Math.min(xMin, x);
                    yMin = Math.min(yMin, y);
                    xMax = Math.max(xMax, x);
                    yMax = Math.max(yMax, y);
                }
                out.push({
                    label: m.label || 'unknown',
                    x: xMin, y: yMin,
                    w: xMax - xMin, h: yMax - yMin,
                    cx: (xMin + xMax) / 2,
                    cy: (yMin + yMax) / 2,
                });
            }
            return out;
        }

        function renderBBoxesAndAxes(bboxes, dims) {
            const svg = ensureOverlaySvg(dims);

            // Draw bboxes
            for (const b of bboxes) {
                const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const isWindow = String(b.label).includes('window');
                const stroke = isWindow ? '#f472b6' : '#fbbf24';
                const fill = isWindow ? 'rgba(244,114,182,0.10)' : 'rgba(251,191,36,0.08)';
                r.setAttribute('x', String(b.x));
                r.setAttribute('y', String(b.y));
                r.setAttribute('width', String(b.w));
                r.setAttribute('height', String(b.h));
                r.setAttribute('fill', fill);
                r.setAttribute('stroke', stroke);
                r.setAttribute('stroke-width', '1.5');
                r.setAttribute('vector-effect', 'non-scaling-stroke');
                svg.appendChild(r);
            }

            // Fit vertical axes using window bboxes
            const windows = bboxes.filter(b => String(b.label).includes('window'));
            windows.sort((a, b) => a.cx - b.cx);
            const clusters = [];
            const tol = 60; // px in ortho coordinate system
            for (const w of windows) {
                const last = clusters[clusters.length - 1];
                if (!last || Math.abs(last.meanX - w.cx) > tol) {
                    clusters.push({ meanX: w.cx, items: [w] });
                } else {
                    last.items.push(w);
                    last.meanX = last.items.reduce((s, it) => s + it.cx, 0) / last.items.length;
                }
            }

            for (const c of clusters) {
                if (c.items.length < 2) continue;
                const ys = c.items.map(it => it.cy).sort((a, b) => a - b);
                const yMin = Math.max(0, ys[0] - 250);
                const yMax = Math.min(dims[1], ys[ys.length - 1] + 250);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', String(c.meanX));
                line.setAttribute('x2', String(c.meanX));
                line.setAttribute('y1', String(yMin));
                line.setAttribute('y2', String(yMax));
                line.setAttribute('stroke', 'rgba(255,255,255,0.55)');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('stroke-dasharray', '6 6');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                svg.appendChild(line);
            }
        }

            const gpuEl = document.getElementById('metricGpu');
            const vramEl = document.getElementById('metricVram');
            const tempEl = document.getElementById('metricTemp');
            if (!gpuEl || !vramEl || !tempEl) return;

            let gpu = 28;
            let vram = 6.2;
            let temp = 62;

            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            setInterval(() => {
                gpu = clamp(gpu + (Math.random() * 6 - 3), 20, 40);
                vram = clamp(vram + (Math.random() * 0.2 - 0.1), 5.6, 7.8);
                temp = clamp(temp + (Math.random() * 2 - 1), 56, 72);
                gpuEl.textContent = `GPU ${gpu.toFixed(0)}%`;
                vramEl.textContent = `VRAM ${vram.toFixed(1)}GB`;
                tempEl.textContent = `TEMP ${temp.toFixed(0)}°C`;
            }, 1000);
        }

        function getStepIndicatorCenter(stepEl, containerEl) {
            const cRect = containerEl.getBoundingClientRect();
            const ind = stepEl.querySelector('.step-indicator')?.getBoundingClientRect();
            if (!ind) return null;
            return {
                x: (ind.left + ind.right) / 2 - cRect.left,
                y: (ind.top + ind.bottom) / 2 - cRect.top,
            };
        }

        function layoutStepConnectors() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;
            const pairs = [
                [1, 2],
                [2, 3],
                [3, 4],
            ];

            for (const [from, to] of pairs) {
                const stepFrom = document.getElementById(`step${from}Btn`);
                const stepTo = document.getElementById(`step${to}Btn`);
                const line = document.getElementById(`stepConnector${from}${to}`);
                const dot = document.getElementById(`stepDot${from}${to}`);
                if (!stepFrom || !stepTo || !line || !dot) continue;

                const c1 = getStepIndicatorCenter(stepFrom, sidebar);
                const c2 = getStepIndicatorCenter(stepTo, sidebar);
                if (!c1 || !c2) continue;

                const xCenter = (c1.x + c2.x) / 2;
                const y1 = c1.y;
                const y2 = c2.y;

                line.style.left = `${xCenter}px`;
                line.style.top = `${y1}px`;
                line.style.height = `${Math.max(0, y2 - y1)}px`;

                dot.style.left = `${xCenter - 7}px`;
                dot.style.top = `${y1 - 7}px`;
            }
        }

        async function animateStepProgress(from, to) {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const stepFrom = document.getElementById(`step${from}Btn`);
            const stepTo = document.getElementById(`step${to}Btn`);
            const line = document.getElementById(`stepConnector${from}${to}`);
            const dot = document.getElementById(`stepDot${from}${to}`);
            if (!stepFrom || !stepTo || !line || !dot) return;

            layoutStepConnectors();
            const c1 = getStepIndicatorCenter(stepFrom, sidebar);
            const c2 = getStepIndicatorCenter(stepTo, sidebar);
            if (!c1 || !c2) return;

            const dy = Math.max(0, c2.y - c1.y);
            dot.style.opacity = '1';
            dot.style.transition = 'transform 650ms cubic-bezier(.2,.8,.2,1), opacity 220ms ease';
            dot.style.transform = `translateY(${dy}px)`;

            // Make the connector a bit brighter once the dot starts moving.
            line.classList.add('active');

            await sleep(700);
            dot.style.opacity = '0';
            dot.style.transform = 'translateY(0)';
            await sleep(220);
        }

        async function showCaseSelector() {
            const modal = document.getElementById('caseSelectorModal');
            const list = document.getElementById('caseList');
            modal.style.display = 'flex';
            try {
                const res = await fetch(`${API_URL}/cases`);
                const buildings = await res.json();
                list.innerHTML = '';
                buildings.forEach(b => {
                    const div = document.createElement('div');
                    div.className = 'case-card';
                    const facadeThumbs = (b.facades || []).map(f => {
                        return `
                          <button type="button" class="facade-thumb" data-facade-id="${f.id}"
                            style="background:none;border:none;padding:0;cursor:pointer;text-align:left;">
                            <img src="${f.thumbnail}" loading="lazy" decoding="async"
                              style="width:100%; height:160px; object-fit:cover; border:1px solid var(--border-color); border-radius:8px;">
                            <div style="padding-top:8px; font-size:12px; color: var(--text-secondary); text-align:center;">${f.label || f.id}</div>
                          </button>
                        `;
                    }).join('');

                    div.innerHTML = `
                      <div style="padding: 16px;">
                        <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                          ${facadeThumbs}
                        </div>
                        <div style="padding-top: 14px; font-size: 14px; text-align:center; font-weight: 700;">${b.name}</div>
                      </div>
                    `;

                    div.querySelectorAll('.facade-thumb').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.preventDefault();
                            const facadeId = btn.getAttribute('data-facade-id');
                            const facade = (b.facades || []).find(x => x.id === facadeId);
                            if (!facade) return;
                            selectedCase = { ...facade, name: b.name, step1_info: b.step1_info, step3_info: b.step3_info, floorplan_svg_base_url: b.floorplan_svg_base_url };
                            modal.style.display = 'none';
                            // Avoid OSS referer-based hotlink issues.
                            mainImage.referrerPolicy = 'no-referrer';
                            fadeInMainImage(selectedCase.original_image || selectedCase.thumbnail, 'contain');
                            log(`Selected building: ${b.name} (${selectedCase.label || selectedCase.id})`, 'info');
                            document.getElementById('step1Btn').disabled = false;
                            document.getElementById('step1Btn').classList.add('active');
                            detectionLayer.innerHTML = '';
                            ['panel1','panel2','panel3'].forEach(id => document.getElementById(id).style.display = 'none');
                        });
                    });
                    list.appendChild(div);
                });
            } catch (e) { log("Failed to load cases", "warn"); }
        }

        function runStep1() {
            (async () => {
                await streamTechLogs('STEP1', [
                    '[STEP1] ingesting facade image',
                    '[STEP1] estimating global scale',
                    '[STEP1] extracting structural priors',
                    '[STEP1] retrieving similar templates',
                    '[STEP1] composing step1 report',
                ]);

                document.getElementById('panel1').style.display = 'block';
                document.getElementById('valStructure').innerText = selectedCase.step1_info.structure;
                document.getElementById('valYear').innerText = selectedCase.step1_info.year;
                document.getElementById('valUse').innerText = selectedCase.step1_info.use;
                log("Appearance recognition complete.", 'success');

                document.getElementById('step1Btn').classList.add('completed');
                await animateStepProgress(1, 2);
                document.getElementById('step2Btn').disabled = false;
                document.getElementById('step2Btn').classList.add('active');
            })();
        }

        async function runStep2() {
            await streamTechLogs('STEP2', [
                '[STEP2] estimating vanishing points',
                '[STEP2] solving homography (DLT + RANSAC)',
                '[STEP2] warping image to ortho plane',
                '[STEP2] running semantic parser',
                '[STEP2] building bounding boxes',
                '[STEP2] exporting debug overlays',
            ]);

            // Ensure Step1 is fully marked completed when Step2 begins.
            document.getElementById('step1Btn').classList.add('completed');

            const orthoSrc = selectedCase.ortho_image || `${API_URL}/demo_data/${selectedCase.id}_ortho.jpg`;
            const fallbackOrtho = `${API_URL}/demo_data/${selectedCase.id}_ortho.jpg`;

            // Start analysis in parallel, but DO NOT render overlays until ortho is shown.
            const formData = new FormData();
            formData.append('case_id', selectedCase.id);
            const analysisPromise = fetch(`${API_URL}/analyze_demo`, { method: 'POST', body: formData }).then(async (r) => {
                const j = await r.json().catch(() => ({}));
                if (!r.ok || j.status === 'error' || j.detail) throw new Error(j.detail || `HTTP ${r.status}`);
                return j;
            });

            log(`Loading ortho: ${orthoSrc}`, 'info');
            const orthoOkPromise = transitionToOrtho(orthoSrc, fallbackOrtho);

            let data;
            try {
                data = await analysisPromise;
                step2Data = data;

                document.getElementById('panel2').style.display = 'block';
                document.getElementById('countWindow').innerText = data.counts.window;
                document.getElementById('countAC').innerText = data.counts.ac;
                document.getElementById('countOther').innerText = data.counts.door;
            } catch (e) {
                log(`Analysis failed: ${e.message || e}`, 'warn');
                return;
            }

            const orthoOk = await Promise.race([orthoOkPromise, sleep(12000).then(() => false)]);
            if (!orthoOk) {
                log('Ortho view still loading; delaying mask render.', 'warn');
                // Don't render masks until ortho is visible; user can retry Step2.
                return;
            }

            log("Ortho view ready. Rendering mask annotations...", 'success');

            // Mask overlay (polygons) aligned to the ortho image.
            if (data.masks && data.debug && data.debug.image_dims) {
                renderMaskOverlay(data.masks, data.debug.image_dims);
            }

            log(`Rendered ${data.debug.boxes_count} masks.`, 'success');
                document.getElementById('step2Btn').classList.add('completed');
                await animateStepProgress(2, 3);
                document.getElementById('step3Btn').disabled = false;
                document.getElementById('step3Btn').classList.add('active');
        }

        function runStep3() {
            (async () => {
                await streamTechLogs('STEP3', [
                    '[STEP3] clustering window columns',
                    '[STEP3] estimating bay spacing',
                    '[STEP3] fitting symmetry axis',
                    '[STEP3] inferring room adjacency graph',
                    '[STEP3] generating layout hypotheses',
                ]);
                log("Analyzing facade geometry...", 'info');

                // Convert masks -> bboxes and fit vertical grid axes.
                if (step2Data && step2Data.masks && step2Data.debug && step2Data.debug.image_dims) {
                    const bboxes = masksToBBoxes(step2Data.masks);
                    renderBBoxesAndAxes(bboxes, step2Data.debug.image_dims);
                } else {
                    log('Missing Step2 mask data; cannot compute axis grid.', 'warn');
                }

            document.getElementById('panel3').style.display = 'block';
            document.getElementById('valBays').innerText = selectedCase.step3_info.bays;
            document.getElementById('valSymmetry').innerText = selectedCase.step3_info.symmetry;
            document.getElementById('valKitchen').innerText = selectedCase.step3_info.kitchen_est;
            document.getElementById('valBedroom').innerText = selectedCase.step3_info.bedroom_est;
            log("Spatial structure analyzed.", 'success');
            document.getElementById('step3Btn').classList.add('completed');
            await animateStepProgress(3, 4);
            document.getElementById('step4Btn').disabled = false;
            document.getElementById('step4Btn').classList.add('active');
            })();
        }

        function runStep4() {
            (async () => {
                await streamTechLogs('STEP4', [
                    '[STEP4] sampling room priors',
                    '[STEP4] optimizing plan constraints',
                    '[STEP4] generating vector walls',
                    '[STEP4] placing doors/windows',
                    '[STEP4] exporting CAD-friendly SVG',
                ]);
                log("Generating interior floor plan...", 'info');
                await renderFloorPlanLayersFromHtml();
                log("Plan generation complete.", 'success');
            })();
        }

        async function renderFloorPlanLayersFromHtml() {
            const viewport = document.getElementById('viewportMain');
            if (!viewport) return;

            const inferFloorplanSvgBaseUrl = () => {
                if (selectedCase && selectedCase.floorplan_svg_base_url) {
                    return String(selectedCase.floorplan_svg_base_url).replace(/\/+$/, '');
                }
                // Backward-compatible inference from the selected facade asset URL.
                const candidate = (selectedCase && (selectedCase.original_image || selectedCase.thumbnail || '')) || '';
                try {
                    const u = new URL(candidate, location.origin);
                    const marker = '/demo/';
                    const idx = u.pathname.indexOf(marker);
                    if (idx !== -1) {
                        return `${u.origin}${u.pathname.slice(0, idx + marker.length)}Untitled`;
                    }
                } catch (e) {}
                return '';
            };

            // Load the authored HTML/CSS layout and render the 7 room layers directly in the viewport.
            const res = await fetch('/floor_plan.html', { cache: 'no-cache' });
            if (!res.ok) {
                log(`Failed to load floor_plan.html (${res.status})`, 'warn');
                return;
            }

            const html = await res.text();
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const styleTag = doc.querySelector('style');
            const canvas = doc.querySelector('.floor-plan-canvas');
            if (!styleTag || !canvas) {
                log('floor_plan.html missing <style> or .floor-plan-canvas', 'warn');
                return;
            }

            const roomImgs = Array.from(canvas.querySelectorAll('img.room-svg'));
            if (roomImgs.length === 0) {
                log('No room layers found in floor_plan.html', 'warn');
                return;
            }

            // Render inside Shadow DOM to prevent the embedded floor_plan CSS (e.g. body/*)
            // from affecting the rest of the dashboard.
            viewport.innerHTML = `<div id="floor-plan-host" style="position:absolute; inset:0;"></div>`;
            const host = viewport.querySelector('#floor-plan-host');
            if (!host) return;
            const shadow = host.shadowRoot || host.attachShadow({ mode: 'open' });
            shadow.innerHTML = `
              <style id="floorPlanInjectedCss"></style>
              <div class="floor-plan-stage" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:#111;">
                <div class="floor-plan-canvas"></div>
              </div>
            `;

            const injectedCss = shadow.querySelector('#floorPlanInjectedCss');
            const canvasHost = shadow.querySelector('.floor-plan-stage .floor-plan-canvas');
            if (!injectedCss || !canvasHost) return;

            // Bring in the original CSS, but override body/container styles and make canvas responsive.
            injectedCss.textContent = `
              ${styleTag.textContent}
              .container, body, h1, .info-panel { display:none !important; }
              .floor-plan-canvas {
                width: min(92%, 980px) !important;
                height: min(92%, 720px) !important;
                aspect-ratio: 1122.5 / 1266.5;
                background: #fafafa !important;
                border: 2px solid rgba(255,255,255,0.10) !important;
                box-shadow: 0 6px 30px rgba(0,0,0,0.35);
              }
              .room-svg { image-rendering: auto; }
            `;

            // Copy the canvas HTML, but render each room as an inline layer element.
            canvasHost.className = 'floor-plan-canvas';
            canvasHost.innerHTML = '';

            // Resolve relative URLs against /floor_plan.html.
            const baseUrl = new URL('/floor_plan.html', location.origin);
            const ossFloorplanBase = inferFloorplanSvgBaseUrl();
            if (ossFloorplanBase) {
                log(`Using OSS floorplan layers: ${ossFloorplanBase}/`, 'info');
            }

            for (const img of roomImgs) {
                const classList = Array.from(img.classList);
                const roomClass = classList.find(c => c !== 'room-svg') || '';
                const src = img.getAttribute('src') || '';
                const alt = img.getAttribute('alt') || roomClass || 'room';
                const abs = new URL(src, baseUrl).toString();
                const fileName = (src.split('/').pop() || '').trim();
                const ossAbs = (ossFloorplanBase && fileName) ? `${ossFloorplanBase}/${fileName}` : '';

                // Container for this layer (positioned by the original CSS).
                const layer = document.createElement('div');
                layer.className = `room-svg ${roomClass}`;

                // Try to inline the SVG content; if missing, fall back to a placeholder.
                try {
                    // Prefer OSS when available to avoid local 404 spam.
                    let svgRes = ossAbs ? await fetch(ossAbs, { cache: 'no-cache' }) : await fetch(abs, { cache: 'no-cache' });
                    if (!svgRes.ok && ossAbs) {
                        // Fall back to local path (dev) if OSS is missing/misconfigured.
                        svgRes = await fetch(abs, { cache: 'no-cache' });
                    }
                    if (svgRes.ok) {
                        const svgText = await svgRes.text();
                        // Wrap the SVG to ensure it scales to the positioned box.
                        layer.innerHTML = `<div style="width:100%; height:100%;">${svgText}</div>`;
                        const svgEl = layer.querySelector('svg');
                        if (svgEl) {
                            svgEl.setAttribute('width', '100%');
                            svgEl.setAttribute('height', '100%');
                            svgEl.setAttribute('preserveAspectRatio', 'none');

                            // Normalize stroke styling across rooms (fixed stroke width, dense dashes, sharp corners).
                            svgEl.querySelectorAll('path, polygon, polyline, rect, line, circle, ellipse').forEach(el => {
                                el.setAttribute('vector-effect', 'non-scaling-stroke');
                                el.setAttribute('stroke-width', '1.2');
                                el.setAttribute('stroke-dasharray', '3 2');
                                el.setAttribute('stroke-linecap', 'butt');
                                el.setAttribute('stroke-linejoin', 'miter');
                                if (el.tagName.toLowerCase() === 'rect') {
                                    el.removeAttribute('rx');
                                    el.removeAttribute('ry');
                                }
                                // Prefer outlines
                                if (!el.getAttribute('stroke')) {
                                    el.setAttribute('stroke', '#111');
                                }
                                el.setAttribute('fill', 'none');
                            });
                        }
                    } else {
                        layer.innerHTML = `
                          <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                            <rect x="2" y="2" width="96" height="96" fill="none" stroke="#22c55e" stroke-width="1.2" stroke-dasharray="3 2" stroke-linecap="butt" stroke-linejoin="miter"/>
                            <text x="50" y="54" text-anchor="middle" font-size="10" fill="#16a34a">${alt}</text>
                          </svg>
                        `;
                    }
                } catch (e) {
                    layer.innerHTML = `
                      <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <rect x="2" y="2" width="96" height="96" fill="none" stroke="#fbbf24" stroke-width="1.2" stroke-dasharray="3 2" stroke-linecap="butt" stroke-linejoin="miter"/>
                        <text x="50" y="54" text-anchor="middle" font-size="10" fill="#f59e0b">${alt}</text>
                      </svg>
                    `;
                }

                canvasHost.appendChild(layer);
            }

            log(`Rendered ${roomImgs.length} room layers into viewport.`, 'success');
        }

        function renderDetections(boxes, dims) {
            detectionLayer.innerHTML = '';
            const rect = detectionLayer.getBoundingClientRect();
            const scaleX = rect.width / dims[0], scaleY = rect.height / dims[1];
            boxes.forEach(box => {
                const [label, x, y, w, h] = box;
                const div = document.createElement('div');
                div.style.cssText = `position:absolute; left:${x*scaleX}px; top:${y*scaleY}px; width:${w*scaleX}px; height:${h*scaleY}px; border:1px solid ${label === 'window' ? '#f472b6' : '#fbbf24'}; background:rgba(${label === 'window' ? '244,114,182' : '251,191,36'}, 0.15);`;
                const s = document.createElement('span');
                s.innerText = label; s.style.cssText = `position:absolute; top:-12px; left:0; font-size:9px; color:white; background:${label === 'window' ? '#f472b6' : '#fbbf24'}; padding:0 3px; border-radius:2px;`;
                div.appendChild(s); detectionLayer.appendChild(div);
            });
        }

        function log(msg, type='info') {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div'); entry.className = `log-entry log-msg ${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            container.appendChild(entry); container.scrollTop = container.scrollHeight;

            const term = document.getElementById('terminal-output');
            if (term) {
                const prefix = new Date().toLocaleTimeString();
                let cls = 'terminal-dim';
                if (type === 'success') cls = '';
                if (type === 'warn') cls = 'terminal-warn';
                if (type === 'error') cls = 'terminal-error';
                const line = document.createElement('div');
                line.className = cls;
                line.textContent = `${prefix}  ${msg}`;
                term.appendChild(line);
                term.scrollTop = term.scrollHeight;
            }
        }

        // Initialize connector line layout
        window.addEventListener('resize', layoutStepConnectors);
        setTimeout(() => {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                const pairs = [
                    [1, 2],
                    [2, 3],
                    [3, 4],
                ];
                for (const [from, to] of pairs) {
                    const line = document.createElement('div');
                    line.id = `stepConnector${from}${to}`;
                    line.className = 'step-connector';
                    sidebar.appendChild(line);

                    const dot = document.createElement('div');
                    dot.id = `stepDot${from}${to}`;
                    dot.className = 'step-dot';
                    sidebar.appendChild(dot);
                }
                layoutStepConnectors();
            }
            initMetricsTicker();
        }, 0);
    </script>
</body>
</html>
